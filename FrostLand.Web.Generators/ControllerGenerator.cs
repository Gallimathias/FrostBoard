using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System;
using System.Linq;
using System.Collections.Generic;
using System.Text;
using Microsoft.CodeAnalysis.Formatting;
using Microsoft.CodeAnalysis.CSharp.Formatting;

namespace FrostLand.Web.Generators
{
    [Generator]
    public class ControllerGenerator : ISourceGenerator
    {
        private const string serializationNamespace = "FrostLand.Web.Generators";
        private const string attributeName = "ControllerGeneratorAttribute";
        private const string attributeFullName = serializationNamespace + "." + attributeName;
        private readonly string attributeText = $@"
using System;
namespace {serializationNamespace}
{{
    [AttributeUsage(AttributeTargets.Class, Inherited = false, AllowMultiple = false)]
    [System.Diagnostics.Conditional(""{nameof(ControllerGenerator)}_DEBUG"")]
    public sealed class {attributeName} : Attribute
    {{
        public {attributeName}()
        {{
        }}
    }}
}}
";

        public void Initialize(GeneratorInitializationContext context)
        {
            context.RegisterForPostInitialization(i => i.AddSource(attributeName, attributeText));
            context.RegisterForSyntaxNotifications(() => new SyntaxReceiver());

        }

        public void Execute(GeneratorExecutionContext context)
        {
            var _ = typeof(Microsoft.CodeAnalysis.CSharp.Formatting.CSharpFormattingOptions);
            var builder = new StringBuilder();

            if (!(context.SyntaxContextReceiver is SyntaxReceiver receiver))
                return;

            var attributeSymbol
                = context
                    .Compilation
                    .GetTypeByMetadataName(attributeFullName);

            foreach (var visitInfo in receiver.VisitInfos)
            {
                var parameters
                    = visitInfo
                        .Methods
                        .SelectMany(m => m.MethodSymbol.Parameters)
                        .ToList();

                foreach (var paramater in parameters)
                {
                    var rawSourceText
                        = $@"
                    using FrostLand.Core;
                    using FrostLand.Web.Model;
                    using Microsoft.AspNetCore.Authorization;
                    using Microsoft.AspNetCore.Mvc;
                    using NonSucking.Framework.Extension.IoC;
                    using System;
                    using System.Collections.Generic;
                    using System.Linq;
                    using System.Threading.Tasks;
                    using {paramater.Type.ContainingNamespace.ToDisplayString()};

                    namespace {visitInfo.TypeSymbol.ContainingNamespace.ToDisplayString()}
                    {{
                        [Route(""api/[controller]"")]
                        [ApiController]
                        [Authorize]
                        public class {paramater.Type.Name}Controller : ControllerBase
                        {{
                            private readonly StorageProvider storageProvider;

                            public {paramater.Type.Name}Controller(StorageProvider storageProvider)
                            {{
                                    this.storageProvider = storageProvider;
                            }}
                            
                            [HttpPost]
                            public void AddOrUpdate({paramater.Type.Name} value)
                            {{
                                return storageProvider.AddOrUpdate(value);
                            }}
                            
                            [HttpGet]
                            public void Get()
                            {{
                                return storageProvider.Find(value);
                            }}
                            [HttpGet({{id}})]
                            public void GetById(int id)
                            {{
                                return storageProvider.AddOrUpdate(value);
                            }}
                            [HttpDelete({{id}})]
                            public void Remove(int id)
                            {{
                                return storageProvider.Remove(value);
                            }}
                        }}
                    }}
                    ";

                    var hintName
                        = $"{visitInfo.TypeSymbol.ToDisplayString()}.autogenerated.cs";
                                       
                    var sourceText = SourceText.From(rawSourceText, Encoding.UTF8);
                    var tree
                     = CSharpSyntaxTree
                     .ParseText(sourceText);

                    var root
                        = tree
                        .GetCompilationUnitRoot();

                    using (var workspace = new AdhocWorkspace())
                    {
                        workspace
                            .AddSolution(SolutionInfo.Create(SolutionId.CreateNewId(), VersionStamp.Default));

                        SyntaxNode formattedCode;
                        try
                        {
                            formattedCode
                               = Formatter
                               .Format(root, workspace);

                        }
                        catch (Exception)
                        {
                            throw;
                        }

                        //MSBuildWorkspace
                        //Workspace.TryGetWorkspace(sourceText, out var workspace);
                        //var formatter = Formatter.Format();

                        context.AddSource(hintName, formattedCode.ToString());
                    }
                }
            }
        }



        private class SyntaxReceiver : ISyntaxContextReceiver
        {
            public List<VisitInfo> VisitInfos { get; } = new List<VisitInfo>();

            /// <summary>
            /// Called for every syntax node in the compilation, we can inspect the nodes and save any information useful for generation
            /// </summary>
            public void OnVisitSyntaxNode(GeneratorSyntaxContext context)
            {
                if (!(context.Node is ClassDeclarationSyntax classDeclarationSyntax)
                    || classDeclarationSyntax.AttributeLists.Count <= 0)
                {
                    return;
                }

                var typeSymbol = context.SemanticModel.GetDeclaredSymbol(classDeclarationSyntax);
                var attributes = typeSymbol.GetAttributes();
                var attribute = attributes.FirstOrDefault(d => d?.AttributeClass.ToDisplayString() == attributeFullName);

                if (attribute == default)
                    return;

                var methods
                    = classDeclarationSyntax
                        .Members
                        .OfType<MethodDeclarationSyntax>()
                        .Select(method => (Syntax: method, Symbol: context.SemanticModel.GetDeclaredSymbol(method)))
                        .Where(method => method.Symbol.Name == "BuildOf")
                        .Select(
                            method => new MethodInfo(method.Syntax, method.Symbol))
                        .ToList();

                VisitInfos.Add(new VisitInfo(classDeclarationSyntax, typeSymbol, attribute, methods: methods));
            }
        }
    }

    internal struct VisitInfo : IEquatable<VisitInfo>
    {
        public ClassDeclarationSyntax ClassDeclaration;
        public INamedTypeSymbol TypeSymbol;
        public AttributeData Attribute;

        public List<TypeGroupInfo> Properties { get; }
        public List<MethodInfo> Methods { get; }

        public VisitInfo(
            ClassDeclarationSyntax classDeclaration,
            INamedTypeSymbol typeSymbol,
            AttributeData attribute,
            List<TypeGroupInfo> properties = default,
            List<MethodInfo> methods = default)
        {
            ClassDeclaration = classDeclaration;
            TypeSymbol = typeSymbol;
            Attribute = attribute;
            Properties = properties ?? new List<TypeGroupInfo>();
            Methods = methods ?? new List<MethodInfo>();
        }

        public override bool Equals(object obj) => obj is VisitInfo info && Equals(info);
        public bool Equals(VisitInfo other) => EqualityComparer<ClassDeclarationSyntax>.Default.Equals(ClassDeclaration, other.ClassDeclaration) && EqualityComparer<INamedTypeSymbol>.Default.Equals(TypeSymbol, other.TypeSymbol) && EqualityComparer<AttributeData>.Default.Equals(Attribute, other.Attribute) && EqualityComparer<List<TypeGroupInfo>>.Default.Equals(Properties, other.Properties);

        public override int GetHashCode()
        {
            var hashCode = -1923588403;
            hashCode = hashCode * -1521134295 + EqualityComparer<ClassDeclarationSyntax>.Default.GetHashCode(ClassDeclaration);
            hashCode = hashCode * -1521134295 + EqualityComparer<INamedTypeSymbol>.Default.GetHashCode(TypeSymbol);
            hashCode = hashCode * -1521134295 + EqualityComparer<AttributeData>.Default.GetHashCode(Attribute);
            hashCode = hashCode * -1521134295 + EqualityComparer<List<TypeGroupInfo>>.Default.GetHashCode(Properties);
            return hashCode;
        }

        public static bool operator ==(VisitInfo left, VisitInfo right) => left.Equals(right);
        public static bool operator !=(VisitInfo left, VisitInfo right) => !(left == right);
    }

    internal struct TypeGroupInfo : IEquatable<TypeGroupInfo>
    {
        public TypeGroupInfo(TypeSyntax typeSyntax, SymbolInfo typeSymbol, PropertyInfo[] properties)
        {
            TypeSyntax = typeSyntax;
            TypeSymbol = typeSymbol;
            Properties = properties;
        }

        public TypeSyntax TypeSyntax { get; set; }
        public SymbolInfo TypeSymbol { get; set; }
        public PropertyInfo[] Properties { get; private set; }

        public override bool Equals(object obj) => obj is TypeGroupInfo info && Equals(info);
        public bool Equals(TypeGroupInfo other) => EqualityComparer<TypeSyntax>.Default.Equals(TypeSyntax, other.TypeSyntax) && TypeSymbol.Equals(other.TypeSymbol) && EqualityComparer<PropertyInfo[]>.Default.Equals(Properties, other.Properties);

        public override int GetHashCode()
        {
            var hashCode = -1055744729;
            hashCode = hashCode * -1521134295 + EqualityComparer<TypeSyntax>.Default.GetHashCode(TypeSyntax);
            hashCode = hashCode * -1521134295 + TypeSymbol.GetHashCode();
            hashCode = hashCode * -1521134295 + EqualityComparer<PropertyInfo[]>.Default.GetHashCode(Properties);
            return hashCode;
        }

        public static bool operator ==(TypeGroupInfo left, TypeGroupInfo right) => left.Equals(right);
        public static bool operator !=(TypeGroupInfo left, TypeGroupInfo right) => !(left == right);
    }

    internal struct PropertyInfo : IEquatable<PropertyInfo>
    {
        public PropertyInfo(PropertyDeclarationSyntax propertyDeclarationSyntax, IPropertySymbol propertySymbol)
        {
            PropertyDeclarationSyntax = propertyDeclarationSyntax;
            PropertySymbol = propertySymbol;
        }

        public PropertyDeclarationSyntax PropertyDeclarationSyntax { get; set; }
        public IPropertySymbol PropertySymbol { get; set; }

        public override bool Equals(object obj) => obj is PropertyInfo info && Equals(info);
        public bool Equals(PropertyInfo other) => EqualityComparer<PropertyDeclarationSyntax>.Default.Equals(PropertyDeclarationSyntax, other.PropertyDeclarationSyntax) && EqualityComparer<IPropertySymbol>.Default.Equals(PropertySymbol, other.PropertySymbol);

        public override int GetHashCode()
        {
            var hashCode = 819844184;
            hashCode = hashCode * -1521134295 + EqualityComparer<PropertyDeclarationSyntax>.Default.GetHashCode(PropertyDeclarationSyntax);
            hashCode = hashCode * -1521134295 + EqualityComparer<IPropertySymbol>.Default.GetHashCode(PropertySymbol);
            return hashCode;
        }

        public static bool operator ==(PropertyInfo left, PropertyInfo right) => left.Equals(right);
        public static bool operator !=(PropertyInfo left, PropertyInfo right) => !(left == right);
    }

    internal struct MethodInfo : IEquatable<MethodInfo>
    {
        public MethodDeclarationSyntax MethodDeclarationSyntax { get; set; }
        public IMethodSymbol MethodSymbol { get; set; }

        public MethodInfo(MethodDeclarationSyntax methodDeclarationSyntax, IMethodSymbol propertySymbol)
        {
            MethodDeclarationSyntax = methodDeclarationSyntax;
            MethodSymbol = propertySymbol;
        }

        public override bool Equals(object obj) => obj is MethodInfo info && Equals(info);
        public bool Equals(MethodInfo other) => EqualityComparer<MethodDeclarationSyntax>.Default.Equals(MethodDeclarationSyntax, other.MethodDeclarationSyntax) && EqualityComparer<IMethodSymbol>.Default.Equals(MethodSymbol, other.MethodSymbol);

        public override int GetHashCode()
        {
            var hashCode = -727185757;
            hashCode = hashCode * -1521134295 + EqualityComparer<MethodDeclarationSyntax>.Default.GetHashCode(MethodDeclarationSyntax);
            hashCode = hashCode * -1521134295 + EqualityComparer<IMethodSymbol>.Default.GetHashCode(MethodSymbol);
            return hashCode;
        }

        public static bool operator ==(MethodInfo left, MethodInfo right) => left.Equals(right);
        public static bool operator !=(MethodInfo left, MethodInfo right) => !(left == right);
    }
}
