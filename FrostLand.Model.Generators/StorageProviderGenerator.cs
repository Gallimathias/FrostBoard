using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Diagnostics;

namespace FrostLand.Model.Generators
{
    [Generator]
    public class StorageProviderGenerator : ISourceGenerator
    {
        private const string attributeText = @"
using System;
namespace FrostLand.Model
{
    [AttributeUsage(AttributeTargets.Class, Inherited = false, AllowMultiple = false)]
    [System.Diagnostics.Conditional(""StorageProviderGenerator_DEBUG"")]
    sealed class StorageProviderAttribute : Attribute
    {
        public StorageProviderAttribute()
        {
        }
    }
}
";

        public void Initialize(GeneratorInitializationContext context)
        {
            // Register the attribute source
            context.RegisterForPostInitialization((i) => i.AddSource("StorageProviderAttribute", attributeText));

            // Register a syntax receiver that will be created for each generation pass
            context.RegisterForSyntaxNotifications(() => new SyntaxReceiver());
        }

        public void Execute(GeneratorExecutionContext context)
        {
            var builder = new StringBuilder();
            //context.AddSource("GenSerializationAttribute", SourceText.From(attributeText, Encoding.UTF8));

            if (!(context.SyntaxContextReceiver is SyntaxReceiver receiver))
                return;

            var attributeSymbol
                = context
                    .Compilation
                    .GetTypeByMetadataName("FrostLand.Model.StorageProviderAttribute");

            foreach (var classToAugment in receiver.ClassesToAugment)
            {
                var sourceText
                    = $@"
                namespace {classToAugment.TypeSymbol.ContainingNamespace.ToDisplayString()}
                {{
                    public partial class {classToAugment.TypeSymbol.Name}
                    {{
                    }}
                }}
                ";
                var hintName
                    = $"{classToAugment.TypeSymbol.Name}_storageprovider.autogenerated.cs";
                context.AddSource(hintName, SourceText.From(sourceText, Encoding.UTF8));
            }
        }


        private class SyntaxReceiver : ISyntaxContextReceiver
        {
            public List<VisitInfo> ClassesToAugment { get; } = new List<VisitInfo>();

            /// <summary>
            /// Called for every syntax node in the compilation, we can inspect the nodes and save any information useful for generation
            /// </summary>
            public void OnVisitSyntaxNode(GeneratorSyntaxContext context)
            {
                // any field with at least one attribute is a candidate for property generation
                if (context.Node is ClassDeclarationSyntax classDeclarationSyntax
                    && classDeclarationSyntax.AttributeLists.Count > 0)
                {
                    var typeSymbol = context.SemanticModel.GetDeclaredSymbol(classDeclarationSyntax);
                    var attributes = typeSymbol.GetAttributes();
                    var attribute = attributes.FirstOrDefault(d => d?.AttributeClass.ToDisplayString() == "FrostLand.Model.StorageProviderAttribute");

                    if (attribute == default)
                        return;

                    ClassesToAugment.Add(new VisitInfo(classDeclarationSyntax, typeSymbol, attribute));
                }
            }
        }

        private struct VisitInfo
        {
            public ClassDeclarationSyntax ClassDeclaration;
            public INamedTypeSymbol TypeSymbol;
            public AttributeData Attribute;

            public VisitInfo(ClassDeclarationSyntax classDeclaration, INamedTypeSymbol typeSymbol, AttributeData attribute)
            {
                ClassDeclaration = classDeclaration;
                TypeSymbol = typeSymbol;
                Attribute = attribute;
            }

            public override bool Equals(object obj) => obj is VisitInfo other && EqualityComparer<ClassDeclarationSyntax>.Default.Equals(ClassDeclaration, other.ClassDeclaration) && EqualityComparer<INamedTypeSymbol>.Default.Equals(TypeSymbol, other.TypeSymbol) && EqualityComparer<AttributeData>.Default.Equals(Attribute, other.Attribute);

            public override int GetHashCode()
            {
                var hashCode = 341329424;
                hashCode = hashCode * -1521134295 + EqualityComparer<ClassDeclarationSyntax>.Default.GetHashCode(ClassDeclaration);
                hashCode = hashCode * -1521134295 + EqualityComparer<INamedTypeSymbol>.Default.GetHashCode(TypeSymbol);
                hashCode = hashCode * -1521134295 + EqualityComparer<AttributeData>.Default.GetHashCode(Attribute);
                return hashCode;
            }

            public void Deconstruct(out ClassDeclarationSyntax item1, out INamedTypeSymbol item2, out AttributeData item3)
            {
                item1 = ClassDeclaration;
                item2 = TypeSymbol;
                item3 = Attribute;
            }

            public static implicit operator (ClassDeclarationSyntax, INamedTypeSymbol, AttributeData)(VisitInfo value) => (value.ClassDeclaration, value.TypeSymbol, value.Attribute);
            public static implicit operator VisitInfo((ClassDeclarationSyntax, INamedTypeSymbol, AttributeData) value) => new VisitInfo(value.Item1, value.Item2, value.Item3);
        }
    }
}
